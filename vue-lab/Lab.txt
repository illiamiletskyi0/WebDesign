Звіт до лабораторної роботи 4
1. Кроки, які були виконані:
 - Створено новий проєкт за допомогою команди:
    npm create vue@latest vue-lab
 - Обрано опції: TypeScript – Yes, Vue Router – Yes, ESLint – Yes, Prettier – Yes.
 - Перехід у папку проєкту:
    cd vue-lab
 - Встановлення залежностей:
    npm install
 - Запуск сервера розробки:
    npm run dev
 - Аналіз структури проєкту (main.ts, router/index.ts, App.vue, компоненти).
 - Створено нову сторінку ContactView.vue у папці src/views/.
 - Додано новий маршрут /contact у файлі src/router/index.ts.
 - Додано нове посилання у <nav> в App.vue.
 - Створено компонент UserCard.vue з типізованими пропсами (username: string, isActive: boolean).
 - Імпортовано та використано UserCard у ContactView.vue.
 - Перевірено роботу маршрутів та типізацію TypeScript.

2. Текст помилки (передача числа замість boolean):
// Помилка типізації:
// Type 'number' is not assignable to type 'boolean'.
// <UserCard username="Student_3" :isActive="1" />

3. Висновки
Використання TypeScript у Vue-проєкті дозволяє виявляти помилки ще під час написання коду,
забезпечує статичну типізацію, підвищує надійність застосунку та робить роботу IDE значно
зручнішою (автодоповнення, підказки, перевірка типів).
Vue Router забезпечує навігацію між сторінками без перезавантаження браузера,
дозволяє будувати SPA-застосунки, структуризує проєкт та робить його масштабованим.
За допомогою маршрутів легко додавати нові сторінки та організовувати логіку переходів.

Звіт до лабораторної роботи 5
1. - Встановлено Tailwind та плагін для Vite.
 - Налаштовано Vite на використання Tailwind через плагін.
 - Додано файл стилів із імпортом Tailwind CSS.
 - Підключено цей CSS у головному файлі застосунку.
 - Перезапущено сервер для застосування змін.

2. Умовні стилі в UserCard.vue для прапорця isActive реалізуються за рахунок динамічного
прив’язування класів у Vue: залежно від значення isActive компонент отримує різні набори
Tailwind-класів, які відповідають потрібному стану. Це робиться через масив або об’єкт у директиві :class,
де Tailwind виступає лише набором утиліт, а Vue визначає, які з них застосувати — наприклад, активний
стан може вмикати bg-blue-500 text-white, а неактивний — bg-gray-100 text-gray-800.

3. Utility-first підхід Tailwind має свої переваги: він значно прискорює роботу,
позбавляє проблем зі специфічністю CSS, дозволяє зосередитися на компонуванні прямо
в шаблоні та забезпечує консистентність дизайну через конфігурацію Tailwind. До того ж,
у продакшені CSS стає дуже компактним завдяки очищенню непотрібних класів.
Але є й недоліки: шаблони можуть захаращуватися великою кількістю класів,
складні стилі важче підтримувати без винесення їх у @apply, менш очевидна семантика
стилів порівняно з класичним CSS, а також повторне використання наборів стилів не таке просте,
як із окремими CSS-класами у <style scoped>. У порівнянні зі scoped CSS, Tailwind дає менше проблем
із каскадом, але гіршу читабельність шаблону; швидший у розробці, але менш зручний для великих компонентів зі складною стилізацією.